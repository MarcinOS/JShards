package shards;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.List;
import java.util.Map;
import java.util.Set;

import shards.ConnectionsHolder.ConnectionCallback;
import utils.Assert;
import utils.ShardsIterables;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

public class ShardsStatement implements Statement {

	protected ConnectionsHolder connections;
	protected Statement metaStatement;
	protected Configuration configuration;
	protected SQLParser parser = new JSqlParser();
	protected List<Result> results;
	protected int currentResult;
	protected boolean closed;
	protected ShardsSelectionStrategy globalStrategy;
	protected Connection connection;
	protected Map<String, Statement> statements = Maps.newLinkedHashMap();
	
	protected int maxRows = 0;
	protected int fetchSize = 0;
	protected int fetchDirection = ResultSet.FETCH_FORWARD;
	protected String cursorName = null;
	protected boolean escapeProcessing = true;
	protected int maxFieldSize = 0;
	protected boolean poolable = false;
	protected int queryTimeout = 0;
	
	protected BatchExecutor batchExecutor = new BatchExecutor();
	private SQLWarning warning;
	

	public ShardsStatement(ShardsConnection connection) throws SQLException {
		this.connection = connection;
		this.connections = connection.getConnections();
		metaStatement = connections.firstConnection().createStatement();
		this.configuration = connection.getConfiguration();
		this.globalStrategy = new GlobalShardsSelectionStrategy();
		
		StrategyInitializer initializer = new StrategyInitializer(configuration);
		initializer.init(this.globalStrategy);
	}
	
	private synchronized Statement createStatement(String shard, Connection connection) throws SQLException {
	    Statement statement = statements.get(shard);
        if (statement == null) {
    		statement = internalCreateStatement(connection);
    		statements.put(shard, statement);
        }
		setStatementFields(statement);
        return statement;
	}
	
    protected void setStatementFields(Statement statement) throws SQLException {
    	//We can't pass maxRows to shards!
        statement.setCursorName(cursorName);
		statement.setFetchSize(fetchSize);
		statement.setFetchDirection(fetchDirection);
		statement.setEscapeProcessing(escapeProcessing);
		statement.setMaxFieldSize(maxFieldSize);
		statement.setPoolable(poolable);
		statement.setQueryTimeout(queryTimeout);
    }

    protected Statement internalCreateStatement(Connection connection) throws SQLException {
        return connection.createStatement();
    }

	public void addBatch(String sql) throws SQLException {
	    ParseResult result = parse(sql);
	    Set<String> shards = result.getSelectedShards();
	    for (String shard : shards) {
	        Connection connection = connections.getConnection(shard);
	        Statement statement = createStatement(shard, connection);
	        String queryToExecute = result.getRewrittenQuery() != null ? result.getRewrittenQuery() : sql;
            statement.addBatch(queryToExecute);
        }
	    batchExecutor.addQuery(shards);
	}
	
	public void clearBatch() throws SQLException {
        metaStatement.clearBatch();
    }
	
	public void cancel() throws SQLException {
	    for (Statement statement : statements.values()) {
            statement.cancel();
        }
	    metaStatement.cancel();
	}

	public void clearWarnings() throws SQLException {
	    for (Statement statement : statements.values()) {
            statement.clearWarnings();
        }
	    metaStatement.clearWarnings();
	}

	public void close() throws SQLException {
	    for (Statement statement : statements.values()) {
            statement.close();
        }
	    metaStatement.close();
		closed = true;
	}

	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
	    // TODO Zaimplementowac
		return metaStatement.execute(sql, autoGeneratedKeys);
	}

	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
	    // TODO Zaimplementowac
	    return metaStatement.execute(sql, columnIndexes);
	}

	public boolean execute(String sql, String[] columnNames) throws SQLException {
	    // TODO Zaimplementowac
	    return metaStatement.execute(sql, columnNames);
	}

	public boolean execute(String sql) throws SQLException {
		ParseResult parseResult = parse(sql);
		final String rewrittenQuery = parseResult.getRewrittenQuery();
		Set<String> shards = parseResult.getSelectedShards();
		return execute(sql, rewrittenQuery, parseResult, shards);
	}

    protected boolean execute(String originalQuery, final String rewrittenQuery, ParseResult parseResult, Set<String> selectedShards) throws SQLException {
        if (selectedShards.size() == 0) {
            throw new SQLException("No shards selected for sql statement: " + originalQuery);
        }
        clearResults();
        String queryToExecute = (rewrittenQuery != null ? rewrittenQuery : originalQuery);
        
        CollectedResults collectedResults = executeQueryOnConnectionsAndCollectResults(selectedShards, queryToExecute);
		
        mergeResults(originalQuery, parseResult, collectedResults.results);

		return collectedResults.resultSetReturned;
    }
    
    protected final class CollectedResults {
        final boolean resultSetReturned;
        final LinkedListMultimap<Integer, Result> results;
        public CollectedResults(boolean resultSetReturned, LinkedListMultimap<Integer, Result> results) {
            this.resultSetReturned = resultSetReturned;
            this.results = results;
        }
    }
    
    protected  CollectedResults executeQueryOnConnectionsAndCollectResults(Set<String> selectedShards, String queryToExecute) throws SQLException {
        LinkedListMultimap<Integer, Result> results = LinkedListMultimap.create();
        boolean resultSetReturned = false;
        for (String shard : selectedShards) {
            connection = connections.getConnection(shard);
            resultSetReturned = executeQueryOnSingleConnectionAndCollectResults(queryToExecute, results, shard, connection);
        }
        return new CollectedResults(resultSetReturned, results);
    }

    protected  boolean executeQueryOnSingleConnectionAndCollectResults(String queryToExecute, LinkedListMultimap<Integer, Result> results, String shard, Connection connection)
            throws SQLException {
        Statement statement = createStatement(shard, connection);
        boolean resultSetReturned = statement.execute(queryToExecute);
        collectResults(results, resultSetReturned, statement);
        return resultSetReturned;
    }

    protected  void collectResults(LinkedListMultimap<Integer, Result> results, boolean resultSetReturned, Statement statement) throws SQLException {
        int resultsCount = 0;
        do {
            if(resultSetReturned) {
                ResultSet resultSet = statement.getResultSet();
                Result result = new Result(resultSet);
                results.put(resultsCount, result);
            } else {
                int updateCount = statement.getUpdateCount();
                Result result = new Result(updateCount);
                results.put(resultsCount, result);
            }
            resultsCount++;
        } while(statement.getMoreResults(KEEP_CURRENT_RESULT) || statement.getUpdateCount() != -1);
    }
    
    protected  void mergeResults(String originalQuery, ParseResult parseResult, LinkedListMultimap<Integer, Result> collectedResults) throws SQLException {
        for (int i = 0; i < collectedResults.keySet().size(); i++) {
            List<Result> resList = collectedResults.get(i);
            Result firstResult = resList.get(0);
            boolean isResultSet = firstResult.resultSet != null;
            if(isResultSet) {
                Iterable<ResultSet> resultSets = Iterables.transform(resList, new Function<Result, ResultSet>() {
                    public ResultSet apply(Result from) {
                        return from.resultSet;
                    }
                });
                List<ResultSet> resultSetsList = Lists.newArrayList(resultSets);
                ResultSet mergedResultSet = mergeResultSets(originalQuery, parseResult, resultSetsList);
                Result result = new Result(mergedResultSet);
                results.add(result);
            } else {
                int updateCount = 0;
                for(Result countResult : resList) {
                    Assert.isTrue(countResult.updateCount > -1, "Update count must be grater than zero");
                    updateCount += countResult.updateCount;
                }
                Result result = new Result(updateCount);
                results.add(result);
            }
        }
    }

	private void clearResults() {
		this.results = Lists.newArrayList();
		this.currentResult = 0;
	}

	public int[] executeBatch() throws SQLException {
	    return batchExecutor.executeBatch(statements);
	}

	public ResultSet executeQuery(final String sql) throws SQLException {
		ParseResult result = parse(sql);
		final String rewrittenQuery = result.getRewrittenQuery();
		Set<String> shards = result.getSelectedShards();

		List<ResultSet> selected = connections.foreach(shards, new ConnectionCallback<ResultSet>() {
			public ResultSet handle(String name, Connection connection) throws SQLException {
				return createStatement(name, connection).executeQuery(rewrittenQuery);
			}
		});
		return mergeResultSets(sql, result, selected);
	}

	protected ResultSet mergeResultSets(final String sql, ParseResult result, List<ResultSet> selected) throws SQLException {
		ShardsResultSet shardsResultSet = new ShardsResultSet(selected);

		increaseIndexesIfAsteriskWereUsed(result, shardsResultSet);

		if (selected.size() > 1) {
			List<Integer> groupByColumns = result.getGroupByColumns();
			if (groupByColumns.size() > 0) {
				shardsResultSet = groupResults(result, shardsResultSet, groupByColumns);
			}

			List<AvgIndex> avgIndexes = result.getAvgIndexes();
			if (avgIndexes.size() > 0) {
				shardsResultSet = countAverages(shardsResultSet, avgIndexes);
			}

			// filtrowanie wyników (klauzula HAVING)
			if (result.hasHaving()) {
				shardsResultSet = parser.filter(sql, shardsResultSet, result.getHavingColumns());
			}
			
			shardsResultSet.sort(result.getOrderByColumns());
		}
		shardsResultSet.removeAddedColumns(result.getColumnsAdded());
		applyLimitAndOffset(result.getLimit(), result.getOffset(), shardsResultSet);
		return shardsResultSet;
	}

	private void applyLimitAndOffset(Long limitFromQuery, long offset, ShardsResultSet shardsResultSet) {
		if(limitFromQuery != null && maxRows != 0) {
			long limit = Math.min(limitFromQuery, maxRows);
			shardsResultSet.limit(limit, offset);
		} else if (limitFromQuery == null && maxRows == 0) {
			shardsResultSet.limit(null, offset);
		} else {
			if(limitFromQuery == null) limitFromQuery = 0L;
			long limit = Math.max(limitFromQuery, maxRows);
			shardsResultSet.limit(limit, offset);
		}
	}

	private void increaseIndexesIfAsteriskWereUsed(ParseResult result, ShardsResultSet shardsResultSet) throws SQLException {
		List<Integer> asteriskIndexes = result.getAsteriskIndexes();
		int returnedColumnsCount = shardsResultSet.getMetaData().getColumnCount();
		int originalColumnsCount = result.getOriginalColumnsCount();
		if (originalColumnsCount > 0) {
			int addedColumnsCount = returnedColumnsCount - originalColumnsCount - result.getColumnsAdded();
			if (addedColumnsCount > 0) {
				int asteriskCount = asteriskIndexes.size();
				int columnsAddedForEveryAsterisk = addedColumnsCount / asteriskCount;
				for (Integer asteriskIdx : asteriskIndexes) {
					increaseIndex(asteriskIdx, columnsAddedForEveryAsterisk, result);
				}
			}
		}
	}

	private void increaseIndex(int fromIdx, int offset, ParseResult result) {
		List<AvgIndex> avgIndexes = result.getAvgIndexes();
		for (AvgIndex avgIndex : avgIndexes) {
			if (avgIndex.getAvgIndex() > fromIdx) {
				avgIndex.setAvgIndex(avgIndex.getAvgIndex() + offset);
			}
			int sumIndex = avgIndex.getSumIndex();
			if (sumIndex > fromIdx) {
				avgIndex.setSumIndex(sumIndex + offset);
			}
		}
		List<Integer> originalGroupByColumns = result.getGroupByColumns();
		List<Integer> groupByColumns = ImmutableList.copyOf(originalGroupByColumns);
		for (int i = 0; i < groupByColumns.size(); i++) {
			Integer idx = groupByColumns.get(i);
			if (idx > fromIdx) {
				originalGroupByColumns.set(i, idx + offset);
			}
		}
		List<OrderByColumn> originalOrderByColumns = result.getOrderByColumns();
		List<OrderByColumn> orderByColumns = ImmutableList.copyOf(originalOrderByColumns);
		for (int i = 0; i < orderByColumns.size(); i++) {
			Integer idx = orderByColumns.get(i).getColumnIndex();
			if (idx > fromIdx) {
				originalOrderByColumns.get(i).setColumnIndex(idx + offset);
			}
		}
	}

	private ShardsResultSet countAverages(ShardsResultSet shardsResultSet, List<AvgIndex> avgIndexes) throws SQLException {
		ShardsResultSet groupedResultSet = new ShardsResultSet(shardsResultSet.getMetaData());
		while (shardsResultSet.next()) {
			Row currentRow = shardsResultSet.getCurrentRow();
			for (AvgIndex avgIndex : avgIndexes) {
				int sumIndex = avgIndex.getSumIndex();
				int sum = shardsResultSet.getInt(sumIndex);
				int count = shardsResultSet.getInt(sumIndex + 1);

				double newAvg = new Double(sum) / count;
				currentRow.setColumnValue(avgIndex.getAvgIndex(), newAvg);
			}
			groupedResultSet.addRow(currentRow);
		}
		return groupedResultSet;
	}

	private ShardsResultSet groupResults(ParseResult result, ShardsResultSet shardsResultSet, List<Integer> groupByColumnsIndexes) throws SQLException {
		ShardsResultSet groupedResultSet = new ShardsResultSet(shardsResultSet.getMetaData());
		List<OrderByColumn> groupByColumnsList = convertIntegerListToOrderByColumnList(groupByColumnsIndexes);
		shardsResultSet.sort(groupByColumnsList);
		if (shardsResultSet.next()) {
			Row row = shardsResultSet.getCurrentRow();
			while (shardsResultSet.next()) {
				Row row2 = shardsResultSet.getCurrentRow();
				if (row.isEquals(row2, groupByColumnsList)) {
					row = row.aggregate(row2, result.getAggregateFunctions());
				} else {
					groupedResultSet.addRow(row);
					row = row2;
				}
			}
			groupedResultSet.addRow(row);
		}
		shardsResultSet = groupedResultSet;
		return shardsResultSet;
	}

	private List<OrderByColumn> convertIntegerListToOrderByColumnList(List<Integer> groupByColumns) {
		Iterable<OrderByColumn> iterable = Iterables.transform(groupByColumns, new Function<Integer, OrderByColumn>() {
			public OrderByColumn apply(Integer idx) {
				return new OrderByColumn(idx, true);
			}
		});
		return Lists.newArrayList(iterable);
	}

	public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
	    return executeUpdate(sql, autoGeneratedKeys, new PreparedStatementParametersList());
	}
	
	protected int executeUpdate(final String sql, final int autoGeneratedKeys, PreparedStatementParametersList preparedStatementParameters) throws SQLException {
		ParseResult result = parse(sql, preparedStatementParameters);
		Set<String> shards = result.getSelectedShards();

		List<Integer> updated = connections.foreach(shards, new ConnectionCallback<Integer>() {
			public Integer handle(String name, Connection connection) throws SQLException {
				return createStatement(name, connection).executeUpdate(sql, autoGeneratedKeys);
			}
		});
		return ShardsIterables.sum(updated);
	}

	public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
	    return executeUpdate(sql, columnIndexes, new PreparedStatementParametersList());
	}
	
	protected int executeUpdate(final String sql, final int[] columnIndexes, PreparedStatementParametersList preparedStatementParameters) throws SQLException {
		ParseResult result = parse(sql, preparedStatementParameters);
		Set<String> shards = result.getSelectedShards();

		List<Integer> updated = connections.foreach(shards, new ConnectionCallback<Integer>() {
			public Integer handle(String name, Connection connection) throws SQLException {
				return createStatement(name, connection).executeUpdate(sql, columnIndexes);
			}
		});
		return ShardsIterables.sum(updated);
	}

	public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
	    return executeUpdate(sql, columnNames, new PreparedStatementParametersList());
	}
	
	protected int executeUpdate(final String sql, final String[] columnNames, PreparedStatementParametersList preparedStatementParameters) throws SQLException {
		ParseResult result = parse(sql, preparedStatementParameters);
		Set<String> shards = result.getSelectedShards();

		List<Integer> updated = connections.foreach(shards, new ConnectionCallback<Integer>() {
			public Integer handle(String name, Connection connection) throws SQLException {
				return createStatement(name, connection).executeUpdate(sql, columnNames);
			}
		});
		return ShardsIterables.sum(updated);
	}

    public int executeUpdate(final String sql) throws SQLException {
		ParseResult result = parse(sql);
		Set<String> shards = result.getSelectedShards();

		List<Integer> updated = connections.foreach(shards, new ConnectionCallback<Integer>() {
			public Integer handle(String name, Connection connection) throws SQLException {
				return createStatement(name, connection).executeUpdate(sql);
			}
		});
		return ShardsIterables.sum(updated);
	}

	private ParseResult parse(final String sql, PreparedStatementParametersList preparedStatementParameters) throws WrongShardsQueryException, SQLParserException {
		ParseResult result = parser.parse(sql, globalStrategy, preparedStatementParameters);
		addWarning(result.getWarning());
		return result;
	}
    
	private void addWarning(SQLWarning warning) {
		if(warning != null) {
			if(this.warning != null) {
				this.warning.setNextWarning(warning);
			} else {
				this.warning = warning;
			}
		}
	}

	private ParseResult parse(final String sql) throws WrongShardsQueryException, SQLParserException {
		ParseResult result = parser.parse(sql, globalStrategy);
		addWarning(result.getWarning());
		return result;
	}

	public Connection getConnection() throws SQLException {
		return connection;
	}

	public int getFetchDirection() throws SQLException {
	    return fetchDirection;
	}

	public int getFetchSize() throws SQLException {
	    return fetchSize;
	}

	public ResultSet getGeneratedKeys() throws SQLException {
	    // TODO Sprawdzić czy execute zostało uruchomione
	    List<ResultSet> resultSets = Lists.newArrayList();
	    for (Statement statement : statements.values()) {
	        resultSets.add(statement.getGeneratedKeys());
        }
		return new ShardsResultSet(resultSets);
	}

	public int getMaxFieldSize() throws SQLException {
	    return maxFieldSize;
	}

	public int getMaxRows() throws SQLException {
		return maxRows;
	}

	public boolean getMoreResults() throws SQLException {
		return getMoreResults(CLOSE_CURRENT_RESULT);
	}

	public boolean getMoreResults(int current) throws SQLException {
		currentResult = Math.min(currentResult+1, results.size());
		if (currentResult < results.size()) {
			ResultSet resultSet = results.get(currentResult).resultSet;
			boolean isUpdate = resultSet == null;
			if(isUpdate) {
				return false;
			}
			switch (current) {
				case CLOSE_CURRENT_RESULT :
					Result result = results.get(currentResult-1);
					closeResultSet(result.resultSet);
					break;
				case CLOSE_ALL_RESULTS :
					closeAllResultSets(currentResult);
					break;
				case KEEP_CURRENT_RESULT :
				default:
					break;
			}
			return true;
		}
		return false;
	}
	
	private void closeAllResultSets(int upto) throws SQLException {
		for (int i = 0; i < upto; i++) {
			Result result = results.get(i);
			ResultSet resultSet = result.resultSet;
			closeResultSet(resultSet);
		}
	}

	private void closeResultSet(ResultSet resultSet) throws SQLException {
		if(resultSet != null && !resultSet.isClosed()) {
			resultSet.close();
		}
	}

	public int getQueryTimeout() throws SQLException {
	    return queryTimeout;
	}

	public ResultSet getResultSet() throws SQLException {
		if (isClosed()) {
			throw new SQLException("Statement has been closed");
		}
		if (noMoreResults()) {
			return null;
		} else {
			Result result = results.get(currentResult);
			return result.resultSet;
		}
	}

	private boolean noMoreResults() {
		return currentResult >= results.size();
	}

	public int getResultSetConcurrency() throws SQLException {
		// TODO Na pewno?
		return ResultSet.CONCUR_READ_ONLY;
	}

	public int getResultSetHoldability() throws SQLException {
		// TODO Na pewno?
		return ResultSet.HOLD_CURSORS_OVER_COMMIT;
	}

	public int getResultSetType() throws SQLException {
		return  ResultSet.TYPE_FORWARD_ONLY;
	}

	public int getUpdateCount() throws SQLException {
		if (noMoreResults()) {
			return -1;
		} else {
			return results.get(currentResult).updateCount;
		}
	}

	public SQLWarning getWarnings() throws SQLException {
		SQLWarning allWarnings = this.warning;
		for (Statement statement : statements.values()) {
			SQLWarning warnings = statement.getWarnings();
			if(warnings != null) {
				if(allWarnings != null) {
					allWarnings.setNextWarning(warnings);
				} else {
					allWarnings = warnings;
				}
			}
		}
		return allWarnings;
	}

	public boolean isClosed() throws SQLException {
		return closed;
	}

	public boolean isPoolable() throws SQLException {
	    return poolable;
	}

	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return metaStatement.isWrapperFor(iface);
	}

	public void setCursorName(String name) throws SQLException {
	    this.cursorName = name;
	}

	public void setEscapeProcessing(boolean enable) throws SQLException {
	    // TODO Zrobic obsluge tego jesli rzeczywiscie ktos tego uzywa (bo parser sie moze wyłożyć)
	    this.escapeProcessing = enable;
	}

	public void setFetchDirection(int direction) throws SQLException {
	    this.fetchDirection = direction;
	}

	public void setFetchSize(int rows) throws SQLException {
	    this.fetchSize = rows;
	}

	public void setMaxFieldSize(int max) throws SQLException {
	    this.maxFieldSize = max;
	}

	public void setMaxRows(int max) throws SQLException {
		if(max < 0) {
			throw new SQLException("MaxRows has to be greater or equal than 0.");
		}
	    this.maxRows = max;
	}

	public void setPoolable(boolean poolable) throws SQLException {
	    this.poolable = poolable;
	}

	/** Max. czas trwania zapytania na pojedynczy shard */
	public void setQueryTimeout(int seconds) throws SQLException {
	    this.queryTimeout = seconds;
	}

	public <T> T unwrap(Class<T> iface) throws SQLException {
		return metaStatement.unwrap(iface);
	}
	
	class Result {
		final ResultSet resultSet;
		final int updateCount;
		
		Result(ResultSet resultSet) {
			this.resultSet = resultSet;
			updateCount = -1;
		}
		
		Result(int updateCount) {
			resultSet = null;
			this.updateCount = updateCount;
		}
	}

}
